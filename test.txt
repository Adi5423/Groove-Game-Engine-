main.cpp
```
#include "Engine.h"

int main() {
    Engine::Init();
    Engine::Run();
    Engine::Shutdown();
    return 0;
}
```

Logger.cpp
```
#include "Logger.h"
#include <iostream>
#include <fstream>
#include <windows.h>

namespace Groove {

    static std::ofstream s_LogFile;
    static bool s_LogToFile = false;

    void Logger::Init(const std::string& logFilePath) {
        if (!logFilePath.empty()) {
            s_LogFile.open(logFilePath, std::ios::out | std::ios::trunc);
            s_LogToFile = s_LogFile.is_open();
        }
    }

    void Logger::Shutdown() {
        if (s_LogToFile) {
            s_LogFile.close();
        }
    }

    void Logger::Info(const std::string& message) { Log(message, LogLevel::Info); }
    void Logger::Warning(const std::string& message) { Log(message, LogLevel::Warning); }
    void Logger::Error(const std::string& message) { Log(message, LogLevel::Error); }
    void Logger::Debug(const std::string& message) { Log(message, LogLevel::Debug); }

    void Logger::Log(const std::string& message, LogLevel level) {
        HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);

        switch (level) {
        case LogLevel::Info:
            SetConsoleTextAttribute(hConsole, 7); // Light gray
            std::cout << "[INFO] ";
            break;
        case LogLevel::Warning:
            SetConsoleTextAttribute(hConsole, 6); // Yellow
            std::cout << "[WARNING] ";
            break;
        case LogLevel::Error:
            SetConsoleTextAttribute(hConsole, 12); // Red
            std::cout << "[ERROR] ";
            break;
        case LogLevel::Debug:
            SetConsoleTextAttribute(hConsole, 9); // Blue
            std::cout << "[DEBUG] ";
            break;
        }

        std::cout << message << std::endl;
        SetConsoleTextAttribute(hConsole, 7); // Reset

        if (s_LogToFile) {
            switch (level) {
            case LogLevel::Info:    s_LogFile << "[INFO] "; break;
            case LogLevel::Warning: s_LogFile << "[WARNING] "; break;
            case LogLevel::Error:   s_LogFile << "[ERROR] "; break;
            case LogLevel::Debug:   s_LogFile << "[DEBUG] "; break;
            }
            s_LogFile << message << std::endl;
        }
    }
}
```

Logger.h
```
#pragma once

#include <string>

namespace Groove {

    enum class LogLevel {
        Info,
        Warning,
        Error,
        Debug
    };

    class Logger {
    public:
        static void Init(const std::string& logFilePath = "");

        static void Info(const std::string& message);
        static void Warning(const std::string& message);
        static void Error(const std::string& message);
        static void Debug(const std::string& message);

        static void Shutdown();

    private:
        static void Log(const std::string& message, LogLevel level);
    };
}
```

Engine.h
```
#pragma once

namespace Engine {
    void Init();
    void Run();
    void Shutdown();
}
```

Engine.cpp
```
#include "Engine.h"
#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <iostream>

static GLFWwindow* window = nullptr;

void Engine::Init() {
    std::cout << "Initializing GLFW..." << std::endl;
    if (!glfwInit()) {
        std::cerr << "[Error] Failed to initialize GLFW!" << std::endl;
        return;
    }

    // Set OpenGL version and profile
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 5);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    // Create window
    window = glfwCreateWindow(1280, 720, "Groove Engine", nullptr, nullptr);
    if (!window) {
        std::cerr << "[Error] Failed to create GLFW window!" << std::endl;
        glfwTerminate();
        return;
    }

    glfwMakeContextCurrent(window);

    // Load OpenGL functions using GLAD
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        std::cerr << "[Error] Failed to initialize GLAD!" << std::endl;
        return;
    }

    std::cout << "OpenGL Version: " << glGetString(GL_VERSION) << std::endl;
}

void Engine::Run() {
    std::cout << "Entering main loop..." << std::endl;
    while (!glfwWindowShouldClose(window)) {
        glClearColor(0.1f, 0.12f, 0.15f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        glfwSwapBuffers(window);
        glfwPollEvents();
    }
}

void Engine::Shutdown() {
    glfwDestroyWindow(window);
    glfwTerminate();
    std::cout << "Shutdown complete." << std::endl;
}
```

engine/CMakeLists.txt
```
add_library(Engine STATIC
    src/Engine.cpp
 "Utils/Logger.cpp" "Utils/Logger.h")

target_include_directories(Engine PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/src)
set(CMAKE_TOOLCHAIN_FILE "D:/vcpkg/scripts/buildsystems/vcpkg.cmake")

# Find and link GLFW and GLAD via vcpkg
find_package(glfw3 CONFIG REQUIRED)
find_package(glad CONFIG REQUIRED)


target_link_libraries(Engine PUBLIC glfw glad::glad)
```

Groove/CmakeLists.txt(main source)
```
cmake_minimum_required(VERSION 3.21)
project(Groove)

add_subdirectory(engine)
add_subdirectory(sandbox)
```

sandbox/CMakeLists.txt
```
add_executable(Sandbox
    "src/main.cpp"
)

target_link_libraries(Sandbox PRIVATE Engine)
target_include_directories(Sandbox PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../engine/src)
```
